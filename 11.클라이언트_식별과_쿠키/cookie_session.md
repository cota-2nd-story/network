# 쿠키와 세션

## HTTP Cookie

쿠키란 서버가 웹 브라우저(클라이언트)에게 전송하는 작은 데이터 조각이다. 브라우저는 이 데이터 조각을 저장해놓았다가 동일한 서버에 재요청 시 헤더에 담아 함께 전송한다.

쿠키는 두 요청이 동일한 웹 브라우저(클라이언트)에서 발생한 것인지 판단할 때 주로 사용한다.

## Cookie 만들기

서버는 HTTP 요청을 받고난 뒤(요청 처리 후) 응답과 함께 Set-Cookie 헤더를 전송할 수 있다.

Set-Cookie 응답 헤더는 서버가 user-agent 값으로 전송시킨다.

```java
    Set-Cookie: [cookie-name]=[cookie-value]
    // 이 헤더는 클라이언트에게 쿠키로 저장하라고 명시하는 것
```

이 헤더 값은 브라우저에 저장되고 이후 헤더 값을 내려준 서버에 다른 요청을 보내게 될 경우 Cookie 헤더 안에 포함되서 같이 전송된다. 중요한 점은 이전 쿠키를 보내준 서버가 동일하고 Cookie scope 조건에 맞는 경우 브라우저는 가지고 있는 모든 쿠키 값을 Cookie 헤더에 담아서 서버에 보낸다는 것이다.

## Cookie scope

크게 쿠기의 범위는 Domain과 Path로 정해진다. 이 두개의 값을 가지고 브라우저는 어떤 요청 시 어떤 쿠키 값을 헤더에 담아서 보낼지 결정한다.

### Domain

쿠키가 전송될 호스트들을 명시하는 속성이다.

만약 명시되지 않았을 경우 현재 문서 위치의 호스트 일부를 기본값으로 가진다. 즉, 응답을 내려준 서버의 호스트를 default 값으로 설정된다.

Domain 값이 명시된 경우 서버 도메인들도 항상 scope에 포함된다.

### Path

쿠키를 전송하기 위하여 요청 URL 내에 반드시 존재해야하는 URL 경로다.

만약 쿠키 속성이 Path=/docs로 설정되었다면,

- /docs
- /docs/web
- /docs/http

위 세가지 경로 모두 쿠키를 전송할 수 있는 조건에 부합된다. (당연히 /, /example/docs 와 같은 경로는 부합되지 않는다.)

## Session

> Session 부분은 tomcat 에서 발행하는 JSESSIONID를 예시로 들면서 설명하겠다.

Session은 서버 입장에서 클라이언트가 동적으로 가지는 여러 정보를 저장하는 저장소다. stateless 한 HTTP 통신의 단점 중 하나는 요청, 응답을 주고 받은 과정 중 다음에도 유용하게 쓰일만한 정보를 저장할 수단이 마땅히 없는 것이다. 이 정보들을 이용하여 클라이언트는 다양한 작업을 할 수 있다한들 서버 입장에선 해당 정보를 알길이 없기 때문에 매번 새로운 정보이면서 동시에 새롭게 세팅(응답 헤더나 본문에)해줘야하는 정보일 뿐이다.

그래서 나온 개념이 세션이다. 보통 쿠키라는 것을 통해 서버는 클라이언트를 식별하는데 그 클라이언트의 정보를 저장하는 곳을 세션이라고 생각하면 된다. 굳이 저장할만한 데이터가 있나 싶은 생각이 들수도 있지만 세션은 매우 유용한 저장소다.

물론 쿠키라는 HTTP 헤더 값을 통해 클라이언트와 서버는 충분히 통신할 수 있다. 예를 들어 A 라는 사용자가 gaejangmo.com이라는 사이트에 접속하여 로그인은 했다고 가정해보자. A 사용자는 abc123이라는 아이디로 로그인을 했으며 (여기서 아이디는 유일한 값이다) 서버는 다음부터 통신부터 A 사용자라는 것을 알기 위해 Set-Cookie 응답 헤더에 loginId=abc123 이라는 값을 내려준다.(Domain, Path 모두 default 설정이다) 그리고 그 다음부터 A 사용자가 서버로 보내는 모든 요청에  Cookie: loginId=abc123 이라는 헤더가 추가되서 전송될 것이다.서버는 그렇게 넘어온 loginId=abc123라는 값을 통해 A 사용자라는 것을 인지하고 요청을 처리할 것이다.

이러한 방식으로 서버는 클라이언트를 충분히 식별할 수 있다. 즉, 여기서 세션이라는 정보는 전혀 사용되지 않았다. 서버는 클라이언트의 HTTP 요청 메세지를 통해 모든 정보를 확인할 수 있었고 그에 맞는 요청을 처리할 수 있었다. 

그러나 이러한 방식은 온전히 괜찮은 방식일까?

그렇다고 할 수 없다. 그 이유는,

첫째, HTTP 헤더 값이 무한히 커질 수 있다. 기본적으로 HTTP 요청 데이터가 커지면 커질수록 통신 비용이 증가하게 된다. 만약 쇼핑중이던 사람이 장바구니에 100개의 물건을 담았다고 가정해보면 logidId 뿐만 아니라 shopping-cart (제가 임의로 지은 이름입니다)라는 쿠키 이름에 100개의 값이 추가되서 통신을 하게 될 것이다.

둘째, 보안적 측면이다. loginId=abc123를 HTTP 통신을 통해 노출시킬 필요가 있을까라는 의문을 품어보면 개인정보에 해당하는 A 사용자의 한 정보를 외부로 노출시킨다는 것은 바람직하지 않다는 결론에 도달할 수 있다. 아이디 가지고 그러냐라고 생각할 수 있지만 만약 그 외 다른 개인 정보가 포함될 수 있는 여지는 언제나 열려있기 때문이다.

그래서 tomcat 서버는 클라이언트에게 서버만 알 수 있는 난수 값의 쿠키를 내려준다. 그리고 실제 정보를 세션이라는 휘발성 저장소에 저장한다. 무슨 말이나면 A 사용자가 [gaejangmo.com](http://gaejangmo.com) 사이트에 로그인을 하면 Set-Cookie로 JSESSIONID=난수 를 내려준다. 그리고 해당 난수를 키로 가지는 저장소에 abc123라는 아이디를 저장한다. (JSESSIONID는 tomcat에서 정한 이름이다)

![](https://user-images.githubusercontent.com/30451129/77444398-1ef34880-6e2f-11ea-8f35-256e89dfeed0.png)

위 화면은 크롬의 개발자 도구의 Application 탭을 눌렀을 때 나오는 화면이다. 현재 seonghun127라는 계정을 가진 사용자가 로그인을 한 상태인데 브라우저가 가지고 있는 쿠키 값을 확인해보니 JSESSIONID 라는 쿠키 이름에 알 수 없는 난수가 값으로 할당되어 있다.

이 난수는 서버만 유용하게 사용할 수 있는 값이며 이 난수 값이 서버에 저장되어 있는 세션 정보를 찾는 키인 셈이다. 하나 비유를 들자면 세션은 서버에 있는 사물함이다. 그곳에는 수많은 사물함들이 있는데 사물함마다 사물함 키가 있다. A라는 사용자가 로그인을 하면 서버는 많은 사물함 중 하나를 골라 로그인 정보를 56번 사물함에 담고 사물함 키로 잠궈 그 56번 사물함 키를 응답에 담아 A 사용자 브라우저로 보낸다. 그 다음 요청 시에는 사물함 키를 같이 보내게되는데 서버는 요청으로 넘어온 키를 받고 56번임을 확인한 뒤 56번 사물함을 열어 로그인 정보를 가지고 유용하게 사용할 수 있다.

이 방식으로 따지면 위에서 언급한 HTTP 헤더 값 증가, 보안 문제를 해결할 수 있다. 새롭게 추가될 shopping-cart 정보 또한 56번 사물함에 담아서 56번 키만 주고받으면 되고 (통신비용 증가x) 서버외 누구도 알 수 없는 56라는 값은 로그인 아이디를 비롯한 여러 정보를 외부로부터 보호할 수 있다.

![](https://user-images.githubusercontent.com/30451129/77444412-231f6600-6e2f-11ea-9323-f9352fefde58.png)

위 화면은 seonghun127 계정으로 [gaejangmo.com](http://gaejangmo.com) 사이트에 로그인한 뒤 새로운 요청을 보내면서 주고 받은 요청, 응답 메세지다. Request Heades를 보면  cookie 헤더에 브라우저에 저장돼있던 JESSIONID 값이 담겨 서버로 전달되고 있다. 이 난수 값 C9CAF26... 값이 위에서 설명한 사물함 56번 키인 것이다.

이를 통해 서버는 세션 저장소에서 요청을 보낸 클라이언트의 정보를 꺼내서 요청에 따라 알맞게 정보를 이용하여 처리할 수 있다. 요청을 보낸 사용자가 누구인지, 쇼핑 카트에 어떤 물품들을 담았는지 쉽게 알 수 있게 되는 것이다.

### reference

- [https://developer.mozilla.org/ko/docs/Web/HTTP/Cookies](https://developer.mozilla.org/ko/docs/Web/HTTP/Cookies)
